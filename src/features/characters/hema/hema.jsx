/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/newAvatart.glb -o src/components/Avatar.jsx -r public 
*/

import React, { useEffect, useMemo, useRef, useState } from 'react'
import { useFrame, useGraph, useLoader } from '@react-three/fiber'
import { useAnimations, useFBX, useGLTF } from '@react-three/drei'
import { SkeletonUtils } from 'three-stdlib'
import * as THREE from 'three';
import { useControls } from 'leva';

const corresponding = {
  A: "viseme_PP",
  B: "viseme_kk",
  C: "viseme_I",
  D: "viseme_AA",
  E: "viseme_O",
  F: "viseme_U",
  G: "viseme_FF",
  H: "viseme_TH",
  X: "viseme_PP"
}

export const Hema = React.memo((props) => {

  useEffect(() => {
    console.log("Hema component was called and mounted 1 time.");
    console.trace("Mount stack trace:");
  }, []); // Empty array ensures this runs only once

  const { playAudio, script } = useControls({
    playAudio: false,
    script: { value: "welcome", options: ["welcome"] },

  })

  const audio = useMemo(() => new Audio(`/characters/hema/audio/${script}.mp3`), [script]);
  const jsonFile = useLoader(THREE.FileLoader, `/characters/hema/audio/${script}.json`);
  const lipSync = JSON.parse(jsonFile);
  const { scene } = useGLTF('/characters/hema/model/hema.glb');
  const { animations: IdleAnimation } = useFBX('/characters/hema/animations/Standing Idle.fbx');
  const { animations: Waving } = useFBX('/characters/hema/animations/Waving.fbx');

  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone);

  IdleAnimation[0].name = "Idle";
  Waving[0].name = "Waving";

  const group = useRef();
  const [animation, setAnimation] = useState("Idle");
  const { actions } = useAnimations([IdleAnimation[0], Waving[0]], group);

  const eyeLeftRef = useRef();
  const eyeRightRef = useRef();
  const blinkInterval = useRef();
  const blinkTimeout = useRef();

  useFrame(() => {
    const currentAudioTime = audio.currentTime;
    for (let i = 0; i < lipSync.mouthCues.length; i++) {
      const mouthCue = lipSync.mouthCues[i]
      if (currentAudioTime >= mouthCue.start && currentAudioTime <= mouthCue.end) {
        console.log(mouthCue.value);
      }
    }
  })

  // Alternative blinking using scale animation
  useEffect(() => {
    if (playAudio) {
      audio.play();
    } else {
      audio.pause();
    }
  }, [playAudio, script]);

  useEffect(() => {
    console.log(nodes.Wolf3D_Head.morphTargetDictionary);
    nodes.Wolf3D_Head.morphTargetInfluences[nodes.Wolf3D_Head.morphTargetDictionary["viseme_O"]] = 1;
    nodes.Wolf3D_Teeth.morphTargetInfluences[nodes.Wolf3D_Teeth.morphTargetDictionary["viseme_O"]] = 1
  }, []);


  useEffect(() => {
    const blink = () => {
      if (!eyeLeftRef.current || !eyeRightRef.current) return;
      console.log("Blink")
      const blinkDuration = 0.2; // seconds
      const startTime = Date.now();

      const animateBlink = () => {
        const elapsed = (Date.now() - startTime) / 1000;
        const progress = Math.min(elapsed / blinkDuration, 1);

        // Create a smooth blink effect using scale
        const scaleY = Math.sin(progress * Math.PI) * 0.1 + 0.9; // Scales between 0.9 and 1.1

        // Apply scale to eyes
        eyeLeftRef.current.scale.y = scaleY;
        eyeRightRef.current.scale.y = scaleY;

        if (progress < 1) {
          requestAnimationFrame(animateBlink);
        } else {
          // Reset to normal scale after blink
          eyeLeftRef.current.scale.y = 1;
          eyeRightRef.current.scale.y = 1;
        }
      };

      requestAnimationFrame(animateBlink);
    };

    // Cleanup any existing intervals/timeouts
    const cleanup = () => {
      if (blinkInterval.current) clearInterval(blinkInterval.current);
      if (blinkTimeout.current) clearTimeout(blinkTimeout.current);
    };

    cleanup();

    // Set up blinking with random intervals
    const scheduleBlink = () => {
      const nextBlink = 2000 + Math.random() * 3000; // 2-5 seconds
      blinkTimeout.current = setTimeout(() => {
        blink();
        scheduleBlink(); // Schedule next blink
      }, nextBlink);
    };

    // Initial blink after short delay
    blinkTimeout.current = setTimeout(() => {
      blink();
      scheduleBlink();
    }, 1000 + Math.random() * 2000);

    return cleanup;
  }, [eyeLeftRef.current, eyeRightRef.current]);

  // Animation controller
  // useEffect(() => {
  //   if (animation === "Waving") {
  //     const action = actions?.[animation];
  //     if (action) {
  //       action.reset().fadeIn(0.5).play().setLoop(THREE.LoopOnce, 1);
  //       action.clampWhenFinished = true;
  //       action.onFinish = () => setAnimation("Idle");
  //     }
  //   }
  // }, [animation, actions]);

  React.useEffect(() => {
    if (actions["Idle"]) {
      actions["Idle"].reset().fadeIn(0.2).play();
    }
  }, [actions]);

  const handlePointerOver = () => {
    if (actions["Waving"]) {
      actions["Idle"]?.fadeOut(0.2);
      actions["Waving"].reset().fadeIn(0.2).play();
    }
  };

  const handlePointerOut = () => {
    if (actions["Waving"]) {
      actions["Waving"].fadeOut(0.2);
      actions["Idle"]?.reset().fadeIn(0.2).play();
    }
  };




  return (
    <group {...props} dispose={null} ref={group} onPointerOver={handlePointerOver}
      onPointerOut={handlePointerOut} >
      <primitive object={nodes.Hips} />
      <skinnedMesh geometry={nodes.Wolf3D_Hair.geometry} material={materials.Wolf3D_Hair} skeleton={nodes.Wolf3D_Hair.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Top.geometry} material={materials.Wolf3D_Outfit_Top} skeleton={nodes.Wolf3D_Outfit_Top.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Bottom.geometry} material={materials.Wolf3D_Outfit_Bottom} skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Footwear.geometry} material={materials.Wolf3D_Outfit_Footwear} skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Body.geometry} material={materials.Wolf3D_Body} skeleton={nodes.Wolf3D_Body.skeleton} />
      <skinnedMesh
        ref={eyeLeftRef}
        name="EyeLeft"
        geometry={nodes.EyeLeft.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeLeft.skeleton}
        morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences}
      />
      <skinnedMesh
        ref={eyeRightRef}
        name="EyeRight"
        geometry={nodes.EyeRight.geometry}
        material={materials.Wolf3D_Eye}
        skeleton={nodes.EyeRight.skeleton}
        morphTargetDictionary={nodes.EyeRight.morphTargetDictionary}
        morphTargetInfluences={nodes.EyeRight.morphTargetInfluences}
      />
      <skinnedMesh
        name="Wolf3D_Head"
        geometry={nodes.Wolf3D_Head.geometry}
        material={materials.Wolf3D_Skin}
        skeleton={nodes.Wolf3D_Head.skeleton}
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary}
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences}
      />
      <skinnedMesh name="Wolf3D_Teeth" geometry={nodes.Wolf3D_Teeth.geometry} material={materials.Wolf3D_Teeth} skeleton={nodes.Wolf3D_Teeth.skeleton} morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary} morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences} />
    </group>
  );
});

useGLTF.preload('/characters/hema/model/hema.glb');